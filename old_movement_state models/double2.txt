data{
  #  Generate vector of 1's for 1's trick for wrapped Cauchy distribution
  for(i in 1:npts){
    ones[i] <- 1
    }  
  }

model{
  #  Define Pi
  Pi <- 3.14159265359  
  
  #  Priors - movement state 1 = station, movement state 2 = transit
    #  Shape parameter for step length distribution
    v[1] ~ dgamma(0.01, 0.01) # Movement state 1
    v[2] ~ dgamma(0.01, 0.01) # Movement state 2

    #  Scale parameter for step length distribution
    lambda[1] <- lambda[2] + eps # Movement state 2
    lambda[2] ~ dgamma(0.01, 0.01) # Movement state 1
    eps ~ dnorm(0, 0.001)T(0,15) # Non-negative variate to add to lambda[1]

    #  Mean cosine of turns
    rho[1] ~ dunif(0.01, 1) # Movement state 1
    rho[2] ~ dunif(0.01, 1) # Movement state 2
    
    #  Mean direction of turns
    mu[1] ~ dunif(-3.14159265359, 3.14159265359) # Movement state 1
    mu[2] ~ dunif(-3.14159265359, 3.14159265359) # Movement state 2

    #  Intercept for state probability
    beta0 ~ dnorm(0, 0.001)T(-5, 5)

    # Random change to the intercept for each individual
    #for (ind in 1:nind){
      #alpha[ind] ~ dnorm(0, 0.001)T(-5, 5)
      #}

  # Likelihood
    #  Generate probability of being in state 1 or 2.
    #  Loop over all observations
    for (t in 1:npts){
      
      #nu[t,1] ~ dunif(0, 1)    ## probability of being in movement state 1 at time t
      #nu[t,2] <- 1 - nu[t, 1]
      #idx[t] ~ dcat(nu[t,])   ##  idx is the latent variable and the parameter index
      
      logit(state[t,1]) <- beta0 #+ alpha[ID[t]] # probability of being in movement state 1 at time t
      state[t,2] <- 1 - state[t,1]
      idx[t] ~ dcat(state[t,]) # Latent state and parameter index

      #  Steps
      l[t] ~ dweib(v[idx[t]], lambda[idx[t]])  

      #  Turns
      # Uses the “ones” trick to sample from the Wrapped Cauchy distribution
      ones[t] ~ dbern(wC[t])
      # PDF for wrapped Cauchy distribution, divided by 500 (arbitrary) to ensure that wC[t] will be less than one
      wC[t] <- (1/(2*Pi)*(1-rho[idx[t]]*rho[idx[t]])/(1+rho[idx[t]]*rho[idx[t]]-2*rho[idx[t]]*cos(theta[t]-mu[idx[t]])))/500
      theta[t] ~ dunif(-3.14159265359, 3.14159265359)
      }
state_1 <- mean(state[,1])
}