data{
	#  Generate vector of 1's for 1's trick for wrapped Cauchy distribution
	for(i in 1:npts){
		ones[i] <- 1
		}	
	}

model{
	#  Priors - movement state 1 = station, movement state 2 = transit
	
		#  Shape parameter for step length distribution
		v[1] ~ dgamma(0.01, 0.01) # Movement state 1
		v[2] ~ dgamma(0.01, 0.01) # Movement state 2
		v[3] ~ dgamma(0.01, 0.01) # Movement state 3
		
		eps[1] ~ dnorm(0.01, 0.01)I(0.0,) 
		eps[2] ~ dnorm(0.01, 0.01)I(0.0,) 
		
		#  Scale parameter for step length distribution
		lambda[3] ~ dgamma(0.01, 0.01) # Movement state 3
		lambda[2] <- lambda[3] + eps[1] # Movement state 2
		lambda[1] <- lambda[2] + eps[2] # Movement state 1
		
		#  Mean cosine of turns
		rho[1] ~ dunif(0, 1) # Movement state 1
		rho[2] ~ dunif(0, 1) # Movement state 2
		rho[3] ~ dunif(0, 1) # Movement state 3
		
		#  Mean direction of turns
		mu[1] ~ dunif(-3.14159265359, 3.14159265359) # Movement state 1
		mu[2] ~ dunif(-3.14159265359, 3.14159265359) # Movement state 2
		mu[3] ~ dunif(-3.14159265359, 3.14159265359) # Movement state 3
		
		#  State probability
		qq[1] ~ dunif(0, 1)
		qq[2] ~ dunif(0, 1)
		qq[3] ~ dunif(0, 1)
		qu[1] ~ dunif(0, 1) # Pr(state 1 at (t) | individ was in state 1 at (t-1))
		qu[2] ~ dunif(0, 1) # Pr(state 1 at (t) | individ was in state 2 at (t-1))
		qu[3] ~ dunif(0, 1)
		
	#  Assign state for first observation 
	idx[1] <- 1
		
	#  Define Pi
	Pi <- 3.14159265359
	
	# Likelihood
	
		#  Loop over all observations
			for (t in 2:npts){
			
				nu[t,1] <- qu[idx[t-1]]
				nu[t,2] <- (1-qu[idx[t-1]]) * qq[idx[t-1]] 
				nu[t,3] <- (1-qu[idx[t-1]]) * (1-qq[idx[t-1]])
				idx[t] ~ dcat(nu[t,]) # Latent state and parameter index
		
				#  Steps
				l[t] ~ dweib(v[idx[t]], lambda[idx[t]])	
				
				#  Turns
				# Uses the “ones” trick to sample from the Wrapped Cauchy distribution
				ones[t] ~ dbern(wC[t])
				# PDF for wrapped Cauchy distribution, divided by 500 (arbitrary) to ensure 
				#   that wC[t] will be less than one
				wC[t] <- (1/(2*Pi)*(1-rho[idx[t]]*rho[idx[t]])/(1+rho[idx[t]]*rho[idx[t]]-2*rho[idx[t]]*cos(theta[t]-mu[idx[t]])))/500

				}
				
	#  Derived parameters
	scale[1] <- (1/lambda[1])^(1/v[1])
	scale[2] <- (1/lambda[2])^(1/v[2])
	scale[3] <- (1/lambda[3])^(1/v[3])
	
	}