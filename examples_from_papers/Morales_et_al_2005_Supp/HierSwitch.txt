model{

# Hyperpriors. These are priors on the parameters of the prior distributions for individual
# level parameters.

# Amu.h and Atau.h are priors for the parameters of the Normal distribution used as prior
# for scale parameter in step length during fast movement. eps.h and epstau.h are priors 
# for the censored Normal used for the difference between scale parameter of step length
# in fast and slow movement. 

Amu.h ~  dnorm(0.0,0.01)I(0,)
Atau.h ~ dnorm(0.0,0.01)I(0,)
eps.h ~ dnorm(0,0.01)I(0,)
epstau.h ~ dnorm(0,0.01)I(0,)

# priors on the parameters of the Normal distributions used as priors on the shape 
# parameters of the Weibul distributions used to model step length
Bmu.h[1] ~ dnorm(0.0,0.01)I(0,)
Bmu.h[2] ~ dnorm(0.0,0.01)I(0,)
Btau.h[1] ~ dnorm(0.0,0.01)I(0,)
Btau.h[2] ~ dnorm(0.0,0.01)I(0,)

# priors on the parameters of the Normal distributions used as priors on the mean
# direction of turning angles
mumean.h[1] ~ dunif(0,6.28318530717959)
mumean.h[2] ~ dunif(0,6.28318530717959)
mutau.h[1] ~ dnorm(0,0.01)I(0.0,)
mutau.h[2] ~ dnorm(0,0.01)I(0.0,)

# priors on the parameters of the Beta distribution used as priors on the mean 
# cosine of turning angles
arho.h[1] ~ dnorm(0,0.001)I(0,)
arho.h[2] ~ dnorm(0,0.001)I(0,)
brho.h[1] ~ dnorm(0,0.001)I(0,)
brho.h[2] ~ dnorm(0,0.001)I(0,)

# priors on the parameters of the Beta distribution used as priors on switching rates
qa.h[1] ~ dnorm(0,0.01)I(0,)
qa.h[2] ~ dnorm(0,0.01)I(0,)
qb.h[1] ~ dnorm(0,0.01)I(0,)
qb.h[2] ~ dnorm(0,0.01)I(0,)

Pi <- 3.14159265359   # define pi
# assign initial state
for(i in 1:npaths){
idx[1,i]~dcat(phi[])
}

# iterate over movement paths
	for(k in 1:npaths){
		# individual level priors
		A[k,2] ~ dnorm(Amu.h, Asigma.h)
		eps[k] ~ dnorm(eps.h, epstau.h)I(0,)
		A[k,1] <- A[k,2] + eps[k]
		B[k,1] ~ dnorm(Bmu.h[1], Btau.h[1]) I(0,)
		B[k,2] ~ dnrom(Bmu.h[2], Btau.h[2]) I(0,)
		RHO[k,1] ~ dbeta(arho.h[1], brho.h[1])
		RHO[k,2] ~ dbeta(arho.h[2], brho.h[2])
		MU[k,1] ~ dnorm(mumean.h[1], mutau.h[1])
		MU[k,2] ~ dnorm(mumean.h[2], mutau.h[2])
		Q[k,1] ~ dbeta(qa.h[1],qb.h[1])
		Q[k,2] ~ dbeta(qa.h[2],qb.h[2])

# iterate over observations
		for (t in 2:npts) {
			l[t,k] ~ dweib(B[k,idx[t,k]], A[k,idx[t,k]]) 

# use 'ones'trick to simulate the wrapped Cauchy distribution
			ones[t,k] <- 1
			ones[t,k] ~ dbern( wc[t,k] )
			wc[t,k] <- (1/(2*Pi)*(1-rho[t,k]*rho[t,k])/(1+rho[t,k]*rho[t,k]-2*rho[t,k]*cos(theta[t,k]-mu.t[t,k])))/ 300

			theta[t,k] ~ dunif(0,6.28318530717959)
			rho[t,k]<-RHO[k,idx[t,k]]
			mu.t[t,k]<- MU[k,idx[t,k]]
			# the probability of being in movement type 1
			p[t,k,1] <- Q[k,idx[t-1,k]]
			p[t,k,2] <- 1-Q[k,idx[t-1,k]]
			idx[t,k] ~ dcat(p[t,k,])
		}
	}
}
