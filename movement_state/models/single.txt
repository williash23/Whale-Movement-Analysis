data{
  #  Generate vector of 1's for 1's trick for wrapped Cauchy distribution
  for(i in 1:npts){
    ones[i] <- 1
    }  
  }
  
model{
   #  Priors - movement state 1 = transit, movement state 2 = stationary
  
    #  Shape parameter for step length distribution
    v0 ~ dgamma(0.01, 0.01)

    #  Scale parameter for step length distribution
    lambda0 ~ dgamma(0.01, 0.01)  

    #  Mean cosine of turns
    rho0 ~ dunif(0, 1)  

    #  Mean direction of turns
    mu0 ~ dunif(-3.14159265359, 3.14159265359)

  # Random change to the intercept for each individual
  # tau_alpha ~ dunif(0, 50)
  # for (ind in 1:nind){
    # alpha[ind] ~ dnorm(0, tau_alpha)T(-5, 5)
    # }

  # Likelihood
    #  Loop over all observations
    for (t in 1:npts){

      #  Steps
      l[t] ~ dweib(v[t], lambda[t])  
      v[t] <- v0
      lambda[t] <- lambda0

      #  Turns
      # Uses the “ones” trick to sample from the Wrapped Cauchy distribution
      ones[t] ~ dbern(wC[t])
      # PDF for wrapped Cauchy distribution, divided by 500 (arbitrary) to ensure that wC[t] will be less than one
      wC[t] <- (1/(2*3.14159265359)*(1-rho[t]*rho[t])/(1+rho[t]*rho[t]-2*rho[t]*cos(theta[t]-mu[t])))/500
      rho[t] <- rho0
      mu[t] <- mu0
      }

    #  Derived parameters
    mean.scale <- (1/mean.lambda)^(1/mean.v)
    mean.mu <- mean(mu[])
    mean.rho <- mean(rho[])
    mean.lambda <- mean(lambda[])
    mean.v <- mean(v[])
    }